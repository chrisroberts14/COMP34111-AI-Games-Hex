<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML lang="en">
<HEAD>
    <META NAME="description" content="Hex is a PC-Game written in HTML and JavaScript">
    <META NAME="author" content="Lutz Tautenhahn">
    <META NAME="keywords" content="Game, Hex, JavaScript">
    <META CONTENT="text/html; charset=iso-8859-1" HTTP-EQUIV="Content-Type">
    <title>Hex</title>
    <style type='text/css'>
        span {
            background-color: #ffffff;
            border: 1px solid #000000;
            cursor: default
        }

        input {
            padding: 0
        }
    </style>
    <script language="JavaScript" type="application/javascript">
        const Size = 11;

        // Display related functions and variables
        // Set images for display
        const Pic = new Array(3);
        Pic[0] = new Image();
        Pic[0].src = "hex_r.gif";
        Pic[1] = new Image();
        Pic[1].src = "hex_t.gif";
        Pic[2] = new Image();
        Pic[2].src = "hex_b.gif";
        const BGPic11 = new Image();
        BGPic11.src = "hex_bg11.gif";
        const BGPic9 = new Image();
        BGPic9.src = "hex_bg9.gif";
        const BGPic13 = new Image();
        BGPic13.src = "hex_bg13.gif";

        const ImgNum = new Array(Size);
        for (let i = 0; i < Size; i++)
            ImgNum[i] = new Array(Size);

        // Necessary for the display
        function WritePotential(bb) {
            if (!IsAI) return;
            if (bb) calculatePotential();
        }

        function RefreshPic(ii, jj) {
            window.document.images[ImgNum[ii][jj]].src = Pic[1 + Board[ii][jj]].src;
        }

        function RefreshScreen() {
            for (let ii = 0; ii < Size; ii++) {
                for (let jj = 0; jj < Size; jj++)
                    document.images[ImgNum[ii][jj]].src = Pic[1 + Board[ii][jj]].src;
            }
        }

        function GetBoardTable() {
            let ii, jj, kk = 0,
                tt = "<table border cellpadding=10 cellspacing=0 bgcolor=#ffffff><tr><td background='hex_bg" + Size + ".gif' align=center>";
            for (ii = 0; ii < Size; ii++) {
                tt += "<nobr>";
                for (jj = 0; jj <= ii; jj++) {
                    tt += "<IMG src=\"hex_t.gif\" border=0 onMouseDown=\"Clicked(" + (ii - jj) + "," + jj + ")\" title='" + String.fromCharCode(65 + jj) + (ii - jj + 1) + "' alt='" + String.fromCharCode(65 + jj) + (ii - jj + 1) + "'>";
                    ImgNum[ii - jj][jj] = kk++;
                }
                tt += "</nobr><br>";
            }
            for (ii = Size - 2; ii >= 0; ii--) {
                tt += "<nobr>";
                for (jj = 0; jj <= ii; jj++) {
                    tt += "<IMG src=\"hex_t.gif\" border=0 onMouseDown=\"Clicked(" + (Size - 1 - jj) + "," + (Size - 1 - ii + jj) + ")\" title='" + String.fromCharCode(65 + Size - 1 - ii + jj) + (Size - jj) + "' alt='" + String.fromCharCode(65 + Size - 1 - ii + jj) + (Size - jj) + "'>";
                    ImgNum[Size - 1 - jj][Size - 1 - ii + jj] = kk++;
                }
                tt += "</nobr><br>";
            }
            tt += "</font></td></tr></table>";
            return (tt);
        }
        // Display functions and variables END

        let IsOver = true, IsStart0 = true, Start0, IsAI = true;
        let potentials = new Array(6);
        const neighborCount = new Array(6);
        let IsRunning = false, LastEvent = "";
        let MoveCount, MaxMoveCount, ActiveColor = 0;
        let IsPlayer = [true, false];

        // Create board array
        const Board = new Array(Size);
        for (let i = 0; i < Size; i++)
            Board[i] = new Array(Size);

        // Create potential array
        const Potential = new Array(Size);
        for (let i = 0; i < Size; i++)
            Potential[i] = new Array(Size);
        for (let i = 0; i < Size; i++) {
            for (let j = 0; j < Size; j++)
                Potential[i][j] = new Array(4);
        }

        // Create bridge array
        const Bridge = new Array(Size);
        for (let i = 0; i < Size; i++)
            Bridge[i] = new Array(Size);
        for (let i = 0; i < Size; i++) {
            for (let j = 0; j < Size; j++)
                Bridge[i][j] = new Array(4);
        }

        // Create update array
        const Upd = new Array(Size);
        for (let i = 0; i < Size; i++)
            Upd[i] = new Array(Size);

        function Init() {
            if ((IsRunning)) {
                LastEvent += "Init();";
                return;
            }
            let ii, jj;
            for (ii = 0; ii < Size; ii++) {
                for (jj = 0; jj < Size; jj++)
                    Board[ii][jj] = 0;
            }
            Start0 = !!IsStart0;
            MoveCount = 0;
            MaxMoveCount = 0;
            RefreshScreen();
            WritePotential(true);
            IsOver = false;
        }

        function Timer() {
            // Execute any pending events if the game is not blinking
            if ((LastEvent !== "")) {
                eval(LastEvent);
                LastEvent = "";
                return;
            }

            // Exit if the game is over, running, or blinking
            if (IsOver || IsRunning) return;

            // If it's the player's turn, update the potential values and exit
            if (IsPlayer[(MoveCount + Start0 + 1) % 2]) {
                WritePotential(true);
                return;
            }

            // Set the game state to running
            IsRunning = true;

            // Check for a swap move
            if (SwapTest()) return;

            // Calculate the potential values for the current state
            calculatePotential();

            // Schedule the GetBestMove function to be called after a short delay
            setTimeout(() => GetBestMove((((MoveCount + 1 + Start0) % 2) * 2 - 1)), 100);
        }

        function SwapTest() {
            // Check if the swap option is enabled
            if (MoveCount > 1) return false;

            // If it's the first move, make a random move
            if (MoveCount === 0) {
                let randomRow = random(4);
                let randomCol = random(4 - randomRow);
                if (random(2) < 1) {
                    randomRow = Size - 1 - randomRow;
                    randomCol = Size - 1 - randomCol;
                }
                MakeMove(randomRow, randomCol, false);
                WritePotential(true);
                IsRunning = false;
                return true;
            }

            // If it's the second move, check for a swap move
            if (MoveCount === 1) {
                for (let row = 0; row < Size; row++) {
                    for (let col = 0; col < Size; col++) {
                        if (Board[row][col] !== 0) {
                            if ((row+col<2)||(row+col>2*Size-4)){
                                return false;
                            }
                            if ((row+col===2)||(row+col===2*Size-4)) {
                                if (random(2)<1) {
                                    return false;
                                }
                            }
                            MakeMove(row, col, false);
                            WritePotential(true);
                            IsRunning=false;
                            return true;
                        }
                    }
                }
            }

            // No swap move made
            return false;
        }

        function MakeMove(row, col, updatePotentials) {
            let swapRow = row, swapCol = col;

            // Handle swap move on the first move
            if (MoveCount === 1) {
                if (Board[row][col] !== 0) {
                    Board[row][col] = 0;
                    RefreshPic(row, col);
                    swapRow = col;
                    swapCol = row;
                }
            }

            // Determine the current player's color
            const currentColor = ((MoveCount + 1 + Start0) % 2) * 2 - 1;

            // Make the move on the board
            Board[swapRow][swapCol] = currentColor;
            RefreshPic(swapRow, swapCol);

            // Increment the move count
            MoveCount++;
            if (MaxMoveCount < MoveCount) {
                MaxMoveCount = MoveCount;
            }

            // If not updating potentials, return
            if (!updatePotentials) return;

            // Update the potentials
            calculatePotential();
            WritePotential(true);

            // Check for win condition
            if (currentColor < 0) {
                if ((Potential[row][col][2] > 0) || (Potential[row][col][3] > 0)) return;
                Blink(0);
            } else {
                if ((Potential[row][col][0] > 0) || (Potential[row][col][1] > 0)) return;
                Blink(0);
            }

            // Set the game over state
            IsOver = true;
        }

        function random(nn) {
            return (Math.floor(Math.random() * 1000) % nn);
        }

        function sign(xx) {
            if (xx < 0) return (-1);
            if (xx > 0) return (1);
            return (0);
        }

        function getDirectionSums() {
            let rowSum = 0;
            let colSum = 0;
            for (let row = 0; row < Size; row++) {
                for (let col = 0; col < Size; col++) {
                    if (Board[row][col] !== 0) {
                        rowSum += 2 * row + 1 - Size;
                        colSum += 2 * col + 1 - Size;
                    }
                }
            }
            return [sign(rowSum), sign(colSum)];
        }

        function isInTopLeftRegion(row, col){
            return (row > 3) && (row < Size - 1) && (col > 0) && (col < 3);
        }

        function isOnTopLeftBorder(row, col){
            return (row === 0) && (col > 0) && (col < 3);
        }

        function isInBottomRightRegion(row, col){
            return (row > 0) && (row < Size - 4) && (col > Size - 4) && (col < Size - 1);
        }

        function isOnBottomRightBorder(row, col){
            return (row === Size - 1) && (col > Size - 4) && (col < Size - 1);
        }

        function isInTopRightRegion(row, col){
            return (row > 3) && (row < Size - 1) && (col > Size - 4) && (col < Size - 1);
        }

        function isOnTopRightBorder(row, col){
            return (row === 0) && (col > Size - 4) && (col < Size - 1);
        }

        function isInBottomLeftRegion(row, col){
            return (row > 0) && (row < Size - 4) && (col > 0) && (col < 3);
        }

        function isOnBottomLeftBorder(row, col){
            return (row === Size - 1) && (col > 0) && (col < 3);
        }

        function isNorthEastBridgePosition(board, row, col, player) {
            // Check if the position at (row - 1, col + 2) contains the opponent's piece
            return board[row - 1][col + 2] === -player;
        }

        function isSouthWestBridgePosition(board, row, col, player) {
            // Check if the position at (row + 1, col - 2) contains the opponent's piece
            return board[row + 1][col - 2] === -player;
        }

        function isSouthEastBridgePosition(board, row, col, player) {
            // Check if the position at (row + 2, col - 1) contains the opponent's piece
            return board[row + 2][col - 1] === -player;
        }

        function isNorthWestBridgePosition(board, row, col, player) {
            // Check if the position at (row - 2, col + 1) contains the opponent's piece
            return board[row - 2][col + 1] === -player;
        }

        function isNorthEastBridgeWithClearPath(board, row, col, player) {
            // Check if the position at (row - 1, col + 2) contains the opponent's piece
            // and all surrounding positions are clear
            return (
                board[row - 1][col + 2] === -player && // Opponent's piece at NE bridge position
                board[row - 1][col] === 0 &&          // North cell is clear
                board[row - 1][col + 1] === 0 &&      // North-East adjacent cell is clear
                board[row][col + 1] === 0 &&          // East cell is clear
                board[row + 1][col] === 0             // South cell is clear
            );
        }

        function isSouthWestBridgeWithClearPath(board, row, col, player) {
            // Check if the position at (row + 1, col - 2) contains the opponent's piece
            // and all surrounding positions are clear
            return (
                board[row + 1][col - 2] === -player && // Opponent's piece at SW bridge position
                board[row + 1][col] === 0 &&          // South cell is clear
                board[row + 1][col - 1] === 0 &&      // South-West adjacent cell is clear
                board[row][col - 1] === 0 &&          // West cell is clear
                board[row - 1][col] === 0             // North cell is clear
            );
        }

        function isSouthEastBridgeWithClearPath(board, row, col, player) {
            // Check if the position at (row + 2, col - 1) contains the opponent's piece
            // and all surrounding positions are clear
            return (
                board[row + 2][col - 1] === -player && // Opponent's piece at SE bridge position
                board[row][col - 1] === 0 &&          // West cell is clear
                board[row + 1][col - 1] === 0 &&      // South-West adjacent cell is clear
                board[row + 1][col] === 0 &&          // South cell is clear
                board[row][col + 1] === 0             // East cell is clear
            );
        }

        function isNorthWestBridgeWithClearPath(board, row, col, player) {
            // Check if the position at (row - 2, col + 1) contains the opponent's piece
            // and all surrounding positions are clear
            return (
                board[row - 2][col + 1] === -player && // Opponent's piece at NW bridge position
                board[row][col + 1] === 0 &&          // East cell is clear
                board[row - 1][col + 1] === 0 &&      // North-East adjacent cell is clear
                board[row - 1][col] === 0 &&          // North cell is clear
                board[row][col - 1] === 0             // West cell is clear
            );
        }

        function calcMovePotential(row, col, factor, rowSum, colSum){
            // Adjust the move potential based on the distance from the center
            let movePotential = (Math.abs(row - 5) + Math.abs(col - 5)) * factor;

            // Adjust the move potential based on the direction sums
            movePotential += 8 * (rowSum * (row - 5) + colSum * (col - 5)) / (MoveCount + 1);

            // Adjust the move potential based on the bridge values
            for (let direction = 0; direction < 4; direction++)
                movePotential -= Bridge[row][col][direction];

            // Sum the potential values for the blue and red players
            const bluePotential = Potential[row][col][0] + Potential[row][col][1];
            const redPotential = Potential[row][col][2] + Potential[row][col][3];
            movePotential += bluePotential + redPotential;

            // Apply a penalty for potential values that are low (i.e. winning moves)
            if ((bluePotential <= 268) || (redPotential <= 268)) movePotential -= 400; //140+128

            return movePotential;
        }

        function GetBestMove(colour) {
            let bestRow, bestCol, factor = 0, rowSum, colSum, connectivity, movePotential;

            // Calculate factor based on move count
            if (MoveCount > 0) factor = 190 / (MoveCount * MoveCount);

            // Set high minimum potential value
            let minPotential = 20000;

            // Get the direction sums
            [rowSum, colSum] = getDirectionSums();

            for (let row = 0; row < Size; row++) {
                for (let col = 0; col < Size; col++) {
                    // Only consider empty cells
                    if (Board[row][col] === 0) {
                        movePotential = calcMovePotential(row, col, factor, rowSum, colSum);

                        // Update the potentials
                        potentials[row * Size + col] = movePotential;

                        // If the move potential is less than the minimum potential, update the minimum potential and best row and column
                        if (movePotential < minPotential) {
                            minPotential = movePotential;
                            bestRow = row;
                            bestCol = col;
                        }
                    }
                }
            }

            minPotential += 108;
            // Loop to check for bridge positions
            // If there is check if it has a potential less than the one found so far
            // If so take that
            for (let row = 0; row < Size; row++) {
                for (let col = 0; col < Size; col++) {
                    // Check if the current position has a lower potential (better)
                    if (potentials[row * Size + col] < minPotential) {
                        if (colour < 0)//red
                        {
                            if (isInTopLeftRegion(row, col)) {
                                if (isNorthEastBridgePosition(Board, row, col, colour)) {
                                    // Decide if the position can connect to the far border
                                    connectivity = CanConnectFarBorder(row - 1, col + 2, -colour);
                                    if (connectivity < 2) {
                                        // If it can connect
                                        bestRow = row;
                                        if (connectivity < -1) {
                                            // An indirect connection exists
                                            bestRow--;
                                            connectivity++;
                                        }
                                        bestCol = col - connectivity;
                                        minPotential = potentials[row * Size + col];
                                    }
                                }
                            }
                            if (isOnTopLeftBorder(row, col)) {
                                if (isNorthEastBridgeWithClearPath(Board, row, col, colour)) {
                                    // Place a bridge in the North-East direction
                                    bestRow = row;
                                    bestCol = col;
                                    minPotential = potentials[row * Size + col];
                                }
                            }
                            if (isInBottomRightRegion(row, col)) {
                                if (isSouthWestBridgePosition(Board, row, col, colour)) {
                                    // Decide if the position can connect to the far border
                                    connectivity = CanConnectFarBorder(row + 1, col - 2, -colour);
                                    if (connectivity < 2) {
                                        // If it can connect
                                        bestRow = row;
                                        if (connectivity < -1) {
                                            // An indirect connection exists
                                            bestRow++;
                                            connectivity++;
                                        }
                                        bestCol = col + connectivity;
                                        minPotential = potentials[row * Size + col];
                                    }
                                }
                            }
                            if (isOnBottomRightBorder(row, col)) {
                                if (isSouthWestBridgeWithClearPath(Board, row, col, colour)) {
                                    // Place a bridge in the South-West direction
                                    bestRow = row;
                                    bestCol = col;
                                    minPotential = potentials[row * Size + col];
                                }
                            }
                        } else {
                            if (isInTopRightRegion(row, col)) {
                                if (isSouthEastBridgePosition(Board, row, col, -colour)) {
                                    // Decide if the position can connect to the far border
                                    connectivity = CanConnectFarBorder(row + 2, col - 1, -colour);
                                    if (connectivity < 2) {
                                        // If it can connect
                                        bestCol = col;
                                        if (connectivity < -1) {
                                            // An indirect connection exists
                                            bestCol--;
                                            connectivity++;
                                        }
                                        bestRow = row - connectivity;
                                        minPotential = potentials[row * Size + col];
                                    }
                                }
                            }
                            if (isOnTopRightBorder(row, col)) {
                                if (isSouthEastBridgeWithClearPath(Board, row, col, -colour)) {
                                    // Place a bridge in the South-East direction
                                    bestRow = row;
                                    bestCol = col;
                                    minPotential = potentials[row * Size + col];
                                }
                            }
                            if (isInBottomLeftRegion(row, col)) {
                                if (isNorthWestBridgePosition(Board, row, col, -colour)) {
                                    // Decide if the position can connect to the far border
                                    connectivity = CanConnectFarBorder(row - 2, col + 1, -colour);
                                    if (connectivity < 2) {
                                        // If it can connect
                                        bestCol = col;
                                        if (connectivity < -1) {
                                            // An indirect connection exists
                                            bestCol++;
                                            connectivity++;
                                        }
                                        bestRow = row + connectivity;
                                        minPotential = potentials[row * Size + col];
                                    }
                                }
                            }
                            if (isOnBottomLeftBorder(row, col)) {
                                if (isNorthWestBridgeWithClearPath(Board, row, col, -colour)) {
                                    // Place a bridge in the North-West direction
                                    bestRow = row;
                                    bestCol = col;
                                    minPotential = potentials[row * Size + col];
                                }
                            }
                        }
                    }
                }
            }
            MakeMove(bestRow, bestCol, false);
            IsRunning = false;
            if (colour < 0) {
                if ((Potential[bestRow][bestCol][2] > 140) || (Potential[bestRow][bestCol][3] > 140)) {
                    WritePotential(false);
                    return;
                }
                Blink(-2);
            } else {
                if ((Potential[bestRow][bestCol][0] > 140) || (Potential[bestRow][bestCol][1] > 140)) {
                    WritePotential(false);
                    return;
                }
                Blink(-2);
            }
            IsOver = true;
        }

        /**
         * Determines if a position can connect to the far border based on specific rules.
         *
         * @param {number} row - Current row position.
         * @param {number} col - Current column position.
         * @param {number} playerColor - Color of the player (positive for blue, negative for red).
         * @returns {number} Connectivity score:
         *                   2 = Cannot connect (blocked),
         *                   1 = Can connect (default),
         *                   0 = Direct connection exists,
         *                  -1 or -2 = Indirect connection based on adjacency.
         */
        function CanConnectFarBorder(row, col, playerColor) {
            // Blue player (positive playerColor)
            if (playerColor > 0) {
                // Check left half of the board
                if (2 * col < Size - 1) {
                    for (let i = 0; i < Size; i++) {
                        for (let j = 0; j < col; j++) {
                            // Blocked by a piece
                            if ((j - i < col - row) && (i + j <= row + col) && (Board[i][j] !== 0)) return 2;
                        }
                    }
                    // Direct or indirect connections
                    if (Board[row - 1][col] === -playerColor) return 0;
                    if (Board[row - 1][col - 1] === -playerColor) {
                        if (GetFld(row + 2, col - 1) === -playerColor) return 0;
                        return -1;
                    }
                    if (GetFld(row + 2, col - 1) === -playerColor) return -2;
                }
                // Check right half of the board
                else {
                    for (let i = 0; i < Size; i++) {
                        for (let j = Size - 1; j > col; j--) {
                            // Blocked by a piece
                            if ((j - i > col - row) && (i + j >= row + col) && (Board[i][j] !== 0)) return 2;
                        }
                    }
                    // Direct or indirect connections
                    if (Board[row + 1][col] === -playerColor) return 0;
                    if (Board[row + 1][col + 1] === -playerColor) {
                        if (GetFld(row - 2, col + 1) === -playerColor) return 0;
                        return -1;
                    }
                    if (GetFld(row - 2, col + 1) === -playerColor) return -2;
                }
            }
            // Red player (negative playerColor)
            else {
                // Check top half of the board
                if (2 * row < Size - 1) {
                    for (let j = 0; j < Size; j++) {
                        for (let i = 0; i < row; i++) {
                            // Blocked by a piece
                            if ((i - j < row - col) && (i + j <= row + col) && (Board[i][j] !== 0)) return 2;
                        }
                    }
                    // Direct or indirect connections
                    if (Board[row][col - 1] === -playerColor) return 0;
                    if (Board[row - 1][col - 1] === -playerColor) {
                        if (GetFld(row - 1, col + 2) === -playerColor) return 0;
                        return -1;
                    }
                    if (GetFld(row - 1, col + 2) === -playerColor) return -2;
                }
                // Check bottom half of the board
                else {
                    for (let j = 0; j < Size; j++) {
                        for (let i = Size - 1; i > row; i--) {
                            // Blocked by a piece
                            if ((i - j > row - col) && (i + j >= row + col) && (Board[i][j] !== 0)) return 2;
                        }
                    }
                    // Direct or indirect connections
                    if (Board[row][col + 1] === -playerColor) return 0;
                    if (Board[row + 1][col + 1] === -playerColor) {
                        if (GetFld(row + 1, col - 2) === -playerColor) return 0;
                        return -1;
                    }
                    if (GetFld(row + 1, col - 2) === -playerColor) return -2;
                }
            }

            // Default case: Can connect
            return 1;
        }

        function GetFld(row, col) {
            if (row < 0) return (-1);
            if (col < 0) return (1);
            if (row >= Size) return (-1);
            if (col >= Size) return (1);
            return (Board[row][col]);
        }

        function Blink() {
            alert("Game Over!");
        }

        function calculatePotential() {
            let direction, iteration, potentialChange, maxIterations = 12;

            // Set the active color based on move count and start offset
            ActiveColor = ((MoveCount + 1 + Start0) % 2) * 2 - 1;

            // Initialize all potentials and bridges
            for (let row = 0; row < Size; row++) {
                for (let col = 0; col < Size; col++) {
                    for (direction = 0; direction < 4; direction++) {
                        Potential[row][col][direction] = 20000;  // Set initial potential values to a large number
                        Bridge[row][col][direction] = 0;   // Set bridge status to 0 (no bridge)
                    }
                }
            }

            // Initialize border conditions for potential values
            for (let row = 0; row < Size; row++) {
                // Handle blue border (left column)
                if (Board[row][0] === 0) {
                    Potential[row][0][0] = 128; // Blue border
                } else if (Board[row][0] > 0) {
                    Potential[row][0][0] = 0;   // Set potential to 0 if it's a blue piece
                }

                // Handle blue border (right column)
                if (Board[row][Size - 1] === 0) {
                    Potential[row][Size - 1][1] = 128; // Blue border
                } else if (Board[row][Size - 1] > 0) {
                    Potential[row][Size - 1][1] = 0;   // Set potential to 0 if it's a blue piece
                }
            }

            for (let col = 0; col < Size; col++) {
                // Handle red border (top row)
                if (Board[0][col] === 0) {
                    Potential[0][col][2] = 128; // Red border
                } else if (Board[0][col] < 0) {
                    Potential[0][col][2] = 0;   // Set potential to 0 if it's a red piece
                }

                // Handle red border (bottom row)
                if (Board[Size - 1][col] === 0) {
                    Potential[Size - 1][col][3] = 128; // Red border
                } else if (Board[Size - 1][col] < 0) {
                    Potential[Size - 1][col][3] = 0;   // Set potential to 0 if it's a red piece
                }
            }

            // Update blue potential values
            for (direction = 0; direction < 2; direction++) {  // Blue potential directions (0 and 1)
                // Mark all cells as needing an update
                for (let row = 0; row < Size; row++) {
                    for (let col = 0; col < Size; col++) {
                        Upd[row][col] = true;
                    }
                }

                iteration = 0;
                do {
                    iteration++;
                    potentialChange = 0;

                    // Traverse the board and update potential values for blue
                    for (let row = 0; row < Size; row++) {
                        for (let col = 0; col < Size; col++) {
                            if (Upd[row][col]) {
                                potentialChange += SetPot(row, col, direction, 1);  // Update blue potential
                            }
                        }
                    }

                    // Traverse the board in reverse order to update blue potential
                    for (let row = Size - 1; row >= 0; row--) {
                        for (let col = Size - 1; col >= 0; col--) {
                            if (Upd[row][col]) {
                                potentialChange += SetPot(row, col, direction, 1);  // Update blue potential
                            }
                        }
                    }
                } while (potentialChange > 0 && iteration < maxIterations); // Stop if no more changes or iteration limit reached
            }

            // Update red potential values
            for (direction = 2; direction < 4; direction++) {  // Red potential directions (2 and 3)
                // Mark all cells as needing an update
                for (let row = 0; row < Size; row++) {
                    for (let col = 0; col < Size; col++) {
                        Upd[row][col] = true;
                    }
                }

                iteration = 0;
                do {
                    iteration++;
                    potentialChange = 0;

                    // Traverse the board and update potential values for red
                    for (let row = 0; row < Size; row++) {
                        for (let col = 0; col < Size; col++) {
                            if (Upd[row][col]) {
                                potentialChange += SetPot(row, col, direction, -1);  // Update red potential
                            }
                        }
                    }

                    // Traverse the board in reverse order to update red potential
                    for (let row = Size - 1; row >= 0; row--) {
                        for (let col = Size - 1; col >= 0; col--) {
                            if (Upd[row][col]) {
                                potentialChange += SetPot(row, col, direction, -1);  // Update red potential
                            }
                        }
                    }
                } while (potentialChange > 0 && iteration < maxIterations); // Stop if no more changes or iteration limit reached
            }
        }

        function SetPot(x, y, direction, colour) {
            // Mark the current cell as updated
            Upd[x][y] = false;

            // Reset the bridge value for the current cell
            Bridge[x][y][direction] = 0;

            // Check if the current cell is empty or contains the opponent's piece if it does, return 0
            if (Board[x][y] === -colour) return (0);

            let addBonus = 0, defaultPotentialIncrement = 140;
            let minPotential = Infinity;
            const defaultBridgeValue = colour !== ActiveColor ? 52 : 66;

            // Calculate the potential values for the surrounding cells
            potentials[0] = PotVal(x + 1, y, direction, colour);
            potentials[1] = PotVal(x, y + 1, direction, colour);
            potentials[2] = PotVal(x - 1, y + 1, direction, colour);
            potentials[3] = PotVal(x - 1, y, direction, colour);
            potentials[4] = PotVal(x, y - 1, direction, colour);
            potentials[5] = PotVal(x + 1, y - 1, direction, colour);

            // Bonus for certain configurations of high potential neighbors
            for (let i = 0; i < 6; i++) {
                if ((potentials[i] >= 30000) && (potentials[(i + 2) % 6] >= 30000)) {
                    if (potentials[(i + 1) % 6] < 0) {
                        addBonus = +32;
                    }else{
                        potentials[(i + 1) % 6] += 128; //512;
                    }
                }
            }

            // Additional bonus for diagonal high potential neighbors
            for (let i = 0; i < 6; i++) {
                if ((potentials[i] >= 30000) && (potentials[(i + 3) % 6] >= 30000)) {
                    addBonus += 30;
                }
            }

            for (let i = 0; i < 6; i++) {
                if (potentials[i] < 0) {
                    potentials[i] += 30000;
                    neighborCount[i] = 10;
                } else neighborCount[i] = 1;
                minPotential = Math.min(minPotential, potentials[i]);
            }

            // Count neighbors with minimum potential
            let minPotentialCount = 0;
            for (let i = 0; i < 6; i++) {
                if (potentials[i] === minPotential) minPotentialCount += neighborCount[i];
            }

            Bridge[x][y][direction] = minPotentialCount / 5;
            if ((minPotentialCount >= 2) && (minPotentialCount < 10)) {
                Bridge[x][y][direction] = defaultBridgeValue + minPotentialCount - 2;
                minPotential -= 32;
            }
            if (minPotentialCount < 2) {
                let nextMinPotential = 30000;
                for (let i = 0; i < 6; i++) {
                    if ((potentials[i] > minPotential) && (nextMinPotential > potentials[i])) nextMinPotential = potentials[i];
                }
                if (nextMinPotential <= minPotential + 104) {
                    Bridge[x][y][direction] = defaultBridgeValue - (nextMinPotential - minPotential) / 4;
                    minPotential -= 64;
                }
                minPotential += nextMinPotential;
                minPotential /= 2;
            }

            if ((x > 0) && (x < Size - 1) && (y > 0) && (y < Size - 1)) {
                Bridge[x][y][direction] += addBonus;
            } else {
                Bridge[x][y][direction] -= 2;
            }

            if (((x === 0) || (x === Size - 1)) && ((y === 0) || (y === Size - 1))) {
                Bridge[x][y][direction] /= 2;
            } // /=4

            if (Bridge[x][y][direction] > 68) {
                Bridge[x][y][direction] = 68;
            } //66

            if (Board[x][y] === colour) {
                if (minPotential < Potential[x][y][direction]) {
                    Potential[x][y][direction] = minPotential;
                    SetUpd(x + 1, y, colour);
                    SetUpd(x, y + 1, colour);
                    SetUpd(x - 1, y + 1, colour);
                    SetUpd(x - 1, y, colour);
                    SetUpd(x, y - 1, colour);
                    SetUpd(x + 1, y - 1, colour);
                    return (1);
                }
                return (0);
            }
            if (minPotential + defaultPotentialIncrement < Potential[x][y][direction]) {
                Potential[x][y][direction] = minPotential + defaultPotentialIncrement;
                SetUpd(x + 1, y, colour);
                SetUpd(x, y + 1, colour);
                SetUpd(x - 1, y + 1, colour);
                SetUpd(x - 1, y, colour);
                SetUpd(x, y - 1, colour);
                SetUpd(x + 1, y - 1, colour);
                return (1);
            }
            return (0);
        }

        function PotVal(row, col, directionIndex, colour) {
            if (row < 0) return (30000);
            if (col < 0) return (30000);
            if (row >= Size) return (30000);
            if (col >= Size) return (30000);
            if (Board[row][col] === 0) return (Potential[row][col][directionIndex]);
            if (Board[row][col] === -colour) return (30000);
            return (Potential[row][col][directionIndex] - 30000);
        }

        function SetUpd(row, col) {
            if (row < 0) return;
            if (col < 0) return;
            if (row >= Size) return;
            if (col >= Size) return;
            Upd[row][col] = true;
        }

        function Clicked(row, col) {
            if (IsOver) return;
            if ((IsRunning)) {
                LastEvent += "Clicked(" + row + "," + col + ");";
                return;
            }
            if (Board[row][col] !== 0) {
                if (MoveCount === 1) {
                    MakeMove(row, col, false);
                }
                return;
            }
            if (!IsPlayer[(MoveCount + Start0 + 1) % 2]) {
                return;
            }
            MakeMove(row, col, true);
        }


    </script>
</head>
<BODY bgcolor=#FFFFA0 text=#000000>
<DIV ALIGN=center>
    <form name="OptionsForm" action="">
        <table border=0>
            <tr>
                <td id='Board' style='vertical-align:middle'>&nbsp;</td>
                <td>&nbsp;</td>
                <td id='AI' style='vertical-align:middle;display:none'>&nbsp;</td>
                <td>&nbsp;</td>
                <td valign=middle>
                    <table border=0 cellpadding=0 cellspacing=0 width=100%>
                        <tr>
                            <td>
                                <table bgcolor=#DDCC88 cellpadding=1 cellspacing=1 width=100%>
                                    <tr>
                                        <td align=left>&nbsp;Size 11x11</td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                        <tr>
                            <td></td>
                        </tr>
                        <tr>
                            <td>
                                <table bgcolor=#DDCC88 cellpadding=1 cellspacing=1 width=100%>
                                    <tr>
                                        <td>Red: Player
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                        <tr>
                            <td></td>
                        </tr>
                        <tr>
                            <td>
                                <table bgcolor=#DDCC88 cellpadding=1 cellspacing=1 width=100%>
                                    <tr>
                                        <td>
                                            <table border=0 cellpadding=0 cellspacing=0 width=100%>
                                                <tr>
                                                    <td>Computer is blue
                                                    </td>
                                                </tr>
                                                <tr>
                                                    <td>&nbsp;Level is 3
                                                    </td>
                                                </tr>
                                            </table>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                        <tr>
                            <td></td>
                        </tr>
                        <tr>
                            <td></td>
                        </tr>
                        <tr>
                            <td></td>
                        </tr>
                        <tr>
                            <td>
                                <table bgcolor=#DDCC88 cellpadding=1 cellspacing=1 width=100%>
                                    <tr>
                                        <td>
                                            <table border=0 cellpadding=0 cellspacing=0 width=100%>
                                                <tr>
                                                    <td align=left><input onClick="Init()"
                                                                          style="width:68px;font-size:15px"
                                                                          type=button
                                                                          value="NEW"></td>
                                                </tr>
                                            </table>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                        <tr>
                            <td></td>
                        </tr>
                    </table>
                </td>
            </tr>
        </table>
    </form>
</DIV>
<script language="JavaScript" type="application/javascript">
    document.getElementById('Board').innerHTML = GetBoardTable();
    Init();
    setInterval("Timer()", 200);
</script>
</BODY>
</HTML>